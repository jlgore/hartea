package report

import (
	"fmt"
	"strings"

	"github.com/jung-kurt/gofpdf/v2"
)

func (g *Generator) generateNativePDF(report *Report, filename string) error {
	// Create PDF with custom page size and margins
	pdf := gofpdf.New("P", "mm", "A4", "")
	pdf.SetMargins(20, 20, 20)
	pdf.SetAutoPageBreak(true, 20)

	// Add page
	pdf.AddPage()

	// Title
	pdf.SetFont("Arial", "B", 24)
	pdf.SetTextColor(0, 122, 204) // Blue color
	pdf.Cell(0, 15, "Hartea Analysis Report - Charting Digital Seas")
	pdf.Ln(20)

	// Subtitle with date
	pdf.SetFont("Arial", "", 12)
	pdf.SetTextColor(102, 102, 102) // Gray color
	pdf.Cell(0, 8, "Generated: "+report.GeneratedAt.Format("January 2, 2006 at 3:04 PM"))
	pdf.Ln(5)
	pdf.Cell(0, 8, "Files: "+strings.Join(report.Files, ", "))
	pdf.Ln(15)

	// Executive Summary
	pdf.SetFont("Arial", "B", 16)
	pdf.SetTextColor(51, 51, 51) // Dark gray
	pdf.Cell(0, 10, "Executive Summary")
	pdf.Ln(12)

	// Summary metrics in a grid
	g.addSummaryGrid(pdf, report)

	// Detailed Metrics Table
	pdf.Ln(15)
	pdf.SetFont("Arial", "B", 16)
	pdf.Cell(0, 10, "Detailed Performance Metrics")
	pdf.Ln(12)

	g.addMetricsTable(pdf, report)

	// Comparison section (if available)
	if report.Comparison != nil {
		pdf.Ln(15)
		pdf.SetFont("Arial", "B", 16)
		pdf.Cell(0, 10, "Performance Comparison")
		pdf.Ln(12)

		g.addComparisonSection(pdf, report)
	}

	// Recommendations
	pdf.Ln(15)
	pdf.SetFont("Arial", "B", 16)
	pdf.Cell(0, 10, "Performance Recommendations")
	pdf.Ln(12)

	g.addRecommendations(pdf, report)

	// Footer
	pdf.Ln(20)
	pdf.SetFont("Arial", "I", 10)
	pdf.SetTextColor(128, 128, 128)
	pdf.Cell(0, 5, "Generated by Hartea - Charting the performance seas, one treasure at a time")

	// Save PDF
	return pdf.OutputFileAndClose(filename)
}

func (g *Generator) addSummaryGrid(pdf *gofpdf.Fpdf, report *Report) {
	// Calculate cell dimensions
	cellWidth := 55.0
	cellHeight := 25.0
	cols := 3

	metrics := []struct {
		value string
		label string
		color []int
	}{
		{fmt.Sprintf("%d", report.Summary.TotalFiles), "Files Analyzed", []int{0, 122, 204}},
		{fmt.Sprintf("%d", report.Summary.TotalRequests), "Total Requests", []int{40, 167, 69}},
		{fmt.Sprintf("%.1fms", report.Summary.AverageLoadTime), "Avg Load Time", getColorForLoadTime(report.Summary.AverageLoadTime)},
		{fmt.Sprintf("%.1fms", report.Summary.AverageTTFB), "Average TTFB", getColorForTTFB(report.Summary.AverageTTFB)},
		{fmt.Sprintf("%.2fMB", report.Summary.TotalTransferMB), "Total Transfer", []int{156, 39, 176}},
		{fmt.Sprintf("%d", report.Summary.TotalErrors), "Total Errors", getColorForErrors(report.Summary.TotalErrors)},
	}

	for i, metric := range metrics {
		// Calculate position
		row := i / cols
		col := i % cols
		x := 20 + float64(col)*cellWidth
		y := pdf.GetY() + float64(row)*cellHeight

		// Set position
		pdf.SetXY(x, y)

		// Draw border
		pdf.SetDrawColor(200, 200, 200)
		pdf.Rect(x, y, cellWidth-2, cellHeight-2, "D")

		// Value
		pdf.SetFont("Arial", "B", 16)
		pdf.SetTextColor(metric.color[0], metric.color[1], metric.color[2])
		pdf.SetXY(x+2, y+3)
		pdf.Cell(cellWidth-4, 8, metric.value)

		// Label
		pdf.SetFont("Arial", "", 10)
		pdf.SetTextColor(102, 102, 102)
		pdf.SetXY(x+2, y+12)
		pdf.Cell(cellWidth-4, 6, metric.label)
	}

	// Move cursor below the grid
	rows := (len(metrics) + cols - 1) / cols
	pdf.SetY(pdf.GetY() + float64(rows)*cellHeight + 5)
}

func (g *Generator) addMetricsTable(pdf *gofpdf.Fpdf, report *Report) {
	// Table headers
	headers := []string{"File", "Load Time", "TTFB", "Requests", "Errors", "Cache %", "Size (MB)"}
	colWidths := []float64{30, 25, 20, 20, 18, 20, 25}

	// Header row
	pdf.SetFont("Arial", "B", 10)
	pdf.SetFillColor(248, 249, 250)
	pdf.SetTextColor(51, 51, 51)

	for i, header := range headers {
		pdf.CellFormat(colWidths[i], 8, header, "1", 0, "C", true, 0, "")
	}
	pdf.Ln(-1)

	// Data rows
	pdf.SetFont("Arial", "", 9)
	for i, metrics := range report.Metrics {
		// Alternating row colors
		if i%2 == 0 {
			pdf.SetFillColor(255, 255, 255)
		} else {
			pdf.SetFillColor(248, 249, 250)
		}

		data := []string{
			report.Files[i],
			fmt.Sprintf("%.1fms", metrics.PageLoadTime),
			fmt.Sprintf("%.1fms", metrics.TTFB),
			fmt.Sprintf("%d", metrics.TotalRequests),
			fmt.Sprintf("%d", metrics.ErrorRequests),
			fmt.Sprintf("%.1f%%", metrics.CacheHitRatio),
			fmt.Sprintf("%.2f", float64(metrics.TotalSize)/(1024*1024)),
		}

		for j, value := range data {
			// Set color based on metric type
			if j == 1 { // Load time
				color := getColorForLoadTime(metrics.PageLoadTime)
				pdf.SetTextColor(color[0], color[1], color[2])
			} else if j == 2 { // TTFB
				color := getColorForTTFB(metrics.TTFB)
				pdf.SetTextColor(color[0], color[1], color[2])
			} else if j == 4 { // Errors
				color := getColorForErrors(metrics.ErrorRequests)
				pdf.SetTextColor(color[0], color[1], color[2])
			} else {
				pdf.SetTextColor(51, 51, 51)
			}

			align := "L"
			if j > 0 {
				align = "C"
			}
			pdf.CellFormat(colWidths[j], 7, value, "1", 0, align, true, 0, "")
		}
		pdf.Ln(-1)
	}
}

func (g *Generator) addComparisonSection(pdf *gofpdf.Fpdf, report *Report) {
	comparison := report.Comparison

	// Summary
	pdf.SetFont("Arial", "", 11)
	pdf.SetTextColor(51, 51, 51)
	summaryText := fmt.Sprintf("Performance Analysis: %d improvements, %d regressions, %d unchanged metrics",
		comparison.Summary.BetterCount,
		comparison.Summary.WorseCount,
		comparison.Summary.UnchangedCount)
	pdf.Cell(0, 8, summaryText)
	pdf.Ln(10)

	// Comparison table
	if len(comparison.Files) >= 2 {
		// Headers
		pdf.SetFont("Arial", "B", 9)
		pdf.SetFillColor(248, 249, 250)

		colWidths := []float64{50, 35, 40, 40}
		headers := []string{"Metric", comparison.Files[0] + " (Base)", comparison.Files[1], "Change"}

		for i, header := range headers {
			pdf.CellFormat(colWidths[i], 8, header, "1", 0, "C", true, 0, "")
		}
		pdf.Ln(-1)

		// Data rows
		pdf.SetFont("Arial", "", 8)
		for i, diff := range comparison.Differences {
			if len(diff.Values) >= 2 && len(diff.Changes) >= 2 {
				// Alternating row colors
				if i%2 == 0 {
					pdf.SetFillColor(255, 255, 255)
				} else {
					pdf.SetFillColor(248, 249, 250)
				}

				// Metric name
				pdf.SetTextColor(51, 51, 51)
				pdf.CellFormat(colWidths[0], 6, diff.Name, "1", 0, "L", true, 0, "")

				// Base value
				pdf.CellFormat(colWidths[1], 6, fmt.Sprintf("%v", diff.Values[0]), "1", 0, "C", true, 0, "")

				// New value
				pdf.CellFormat(colWidths[2], 6, fmt.Sprintf("%v", diff.Values[1]), "1", 0, "C", true, 0, "")

				// Change with color coding
				change := diff.Changes[1]
				if len(diff.Improvements) > 1 {
					if diff.Improvements[1] {
						pdf.SetTextColor(40, 167, 69) // Green for improvement
						change += " ✓"
					} else if change != "No change" && change != "Baseline" {
						pdf.SetTextColor(220, 53, 69) // Red for regression
						change += " !"
					} else {
						pdf.SetTextColor(108, 117, 125) // Gray for no change
					}
				}
				pdf.CellFormat(colWidths[3], 6, change, "1", 0, "C", true, 0, "")

				pdf.Ln(-1)
			}
		}
	}
}

func (g *Generator) addRecommendations(pdf *gofpdf.Fpdf, report *Report) {
	recommendations := g.generateRecommendations(report)

	pdf.SetFont("Arial", "", 11)
	pdf.SetTextColor(51, 51, 51)

	if len(recommendations) == 0 {
		pdf.Cell(0, 8, "• Performance metrics are within acceptable ranges")
		return
	}

	for _, rec := range recommendations {
		// Check if we need a new page
		if pdf.GetY() > 250 {
			pdf.AddPage()
		}

		// Bullet point
		pdf.Cell(5, 6, "•")

		// Recommendation text (with word wrapping)
		lines := g.wrapText(rec, 80)
		for i, line := range lines {
			if i == 0 {
				pdf.SetX(25) // Indent after bullet
			} else {
				pdf.SetX(25) // Maintain indent
				pdf.Ln(6)
			}
			pdf.Cell(0, 6, line)
		}
		pdf.Ln(8)
	}
}

func (g *Generator) generateRecommendations(report *Report) []string {
	var recommendations []string

	// Analyze average metrics
	summary := report.Summary

	if summary.AverageLoadTime > 3000 {
		recommendations = append(recommendations, "Page load time exceeds 3 seconds - consider optimizing critical rendering path and reducing resource sizes")
	}

	if summary.AverageTTFB > 800 {
		recommendations = append(recommendations, "Time to First Byte is high - optimize server response time and consider using a CDN")
	}

	if summary.TotalErrors > 0 {
		recommendations = append(recommendations, fmt.Sprintf("Found %d HTTP errors - review and fix failed requests to improve reliability", summary.TotalErrors))
	}

	if summary.TotalTransferMB > 5 {
		recommendations = append(recommendations, "Total transfer size is large - enable compression, optimize images, and minimize CSS/JS")
	}

	// Check individual file metrics
	for i, metrics := range report.Metrics {
		if metrics.CacheHitRatio < 30 {
			recommendations = append(recommendations, fmt.Sprintf("File %d has poor cache efficiency (%.1f%%) - review caching headers and strategy", i+1, metrics.CacheHitRatio))
		}

		if metrics.ThirdPartyRequests > metrics.TotalRequests/2 {
			recommendations = append(recommendations, fmt.Sprintf("File %d has many third-party requests - consider reducing external dependencies", i+1))
		}
	}

	// Comparison-based recommendations
	if report.Comparison != nil {
		for _, diff := range report.Comparison.Differences {
			if len(diff.Changes) > 1 && len(diff.Improvements) > 1 {
				if !diff.Improvements[1] && diff.Changes[1] != "No change" {
					if diff.Name == "Total Load Time" {
						recommendations = append(recommendations, "Performance regression detected in load time - investigate recent changes")
					} else if diff.Name == "Error Requests" && strings.Contains(diff.Changes[1], "+") {
						recommendations = append(recommendations, "Error rate increased - check for new issues or broken functionality")
					}
				}
			}
		}
	}

	return recommendations
}

func (g *Generator) wrapText(text string, maxChars int) []string {
	if len(text) <= maxChars {
		return []string{text}
	}

	var lines []string
	words := strings.Fields(text)
	currentLine := ""

	for _, word := range words {
		if len(currentLine)+len(word)+1 <= maxChars {
			if currentLine != "" {
				currentLine += " "
			}
			currentLine += word
		} else {
			if currentLine != "" {
				lines = append(lines, currentLine)
			}
			currentLine = word
		}
	}

	if currentLine != "" {
		lines = append(lines, currentLine)
	}

	return lines
}

// Color helper functions
func getColorForLoadTime(loadTime float64) []int {
	if loadTime <= 1500 {
		return []int{40, 167, 69} // Green
	} else if loadTime <= 3000 {
		return []int{255, 193, 7} // Yellow
	}
	return []int{220, 53, 69} // Red
}

func getColorForTTFB(ttfb float64) []int {
	if ttfb <= 200 {
		return []int{40, 167, 69} // Green
	} else if ttfb <= 800 {
		return []int{255, 193, 7} // Yellow
	}
	return []int{220, 53, 69} // Red
}

func getColorForErrors(errors int) []int {
	if errors == 0 {
		return []int{40, 167, 69} // Green
	} else if errors <= 5 {
		return []int{255, 193, 7} // Yellow
	}
	return []int{220, 53, 69} // Red
}
